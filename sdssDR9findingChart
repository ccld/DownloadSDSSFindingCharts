#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Usage: sdssDR9findingChart fileWithAstroObjects

fileWithAstroObjects is a text file with an astronomical source name
per line. Non-valid names are ignored. The result is a finding chart
from SDSS DR9 as a JPEG downloaded in the directory from which the
sdssDR9findingChart script is called.

See details of the DS9 Finding chart web service at:
  http://skyserver.sdss3.org/dr9/en/tools/chart/chart.asp
"""

from __future__ import division

import functools
import multiprocessing
import os
import sys
import time
import urllib

sesameQueryUrl = 'http://vizier.u-strasbg.fr/viz-bin/nph-sesame/-op/NSVA?%(name)s'
sdssQueryUrl   = 'http://skyservice.pha.jhu.edu/DR9/ImgCutout/getjpeg.aspx?'

def download_chart(args):
    """ Download the finding chart for an astronomical object (first element of
    the three-element tuple 'args') to a path (second element of the tuple), 
    adjusting or not the scale to the distance (third element of the tuple)"""

    object_name, img_path, doScaling = args

    # Perform the Sesame query
    try:
        sesameQuery = sesameQueryUrl % {'name': urllib.quote(object_name.strip())}
        print "Processing Sesame query for %s" % object_name

        sesameResponse = urllib.urlopen(sesameQuery).readlines()
        sesameResponse = map(lambda x: x.rstrip('\r\n'), sesameResponse)
        ra, dec = filter(lambda x: x.find('%J') == 0, sesameResponse)[0].split(' ')[1:3]
        scale = 0.396127
        if (doScaling):
            try:
                velocityList = filter(lambda x: x.find('%V') == 0, sesameResponse)
                if len(velocityList) > 0:
                    velElements = velocityList[0].split(' ')
                    if velElements[1] == 'v':
                        vel = float(velElements[2])
                    elif velElements[1] == 'z':
                        vel = 299792.458*float(velElements[2])
            except ValueError, e:
                vel = None
            if vel != None:
                scale = scale  * 1500 / vel # Consider the scale 
        # SDSS DR9
        sdssParamsDict = {
            'ra':     ra,
            'dec':    dec,
            'scale':  scale,
            'width':  1024,
            'height': 1024,
            'opt':   'G',
            'query': 'SR(10,10)'
        }

        try:
            print "Querying SDSS for coordinates %s %s (%s)" % (ra, dec, object_name)
            url = sdssQueryUrl + urllib.urlencode(sdssParamsDict)

            def remove(path):
                """ Remove a partially downloaded file, ignore errors """
                try: os.unlink(path)
                except: pass

            try:
                urllib.urlretrieve(url, filename = img_path)
                print "Download of %s completed" % img_path
            except KeyboardInterrupt:
                remove(img_path)
                sys.exit(1)
            except:
                remove(img_path)
                print "Download of %s failed" % img_path

        except Exception, e:
            print "Error. Coordinates %s %s not found in SDSS" % (ra, dec)

    except Exception, e:
        print "Error. Coordinates for %s not found in Sesame" % object_name
        print e


if __name__ == "__main__":
    with open(sys.argv[1],'r') as f:
        # Get only non-empty lines, stripped of trailing blanks and \n
        objects = filter(lambda x: len(x)>0, map(lambda x: x.strip(), f.readlines()))

        # Use a pool of workers and download the images in parallel.
        # The number of workers is that of CPUs in the system.
        # As there is more latency than processing, use double the CPU count
        pool = multiprocessing.Pool(2*multiprocessing.cpu_count())
        map_async_args = ((name, name.strip() + '.jpg', True) for name in objects)
        result = pool.map_async(download_chart, map_async_args)

        while not result.ready():
            time.sleep(1)
        result.get()      # reraise exceptions of the remote call, if any

